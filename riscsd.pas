{*********************************}
{ Generated by c2pas32  v0.9b     }
{ (c) 2001 Oleg Bulychov          }
{ Gladiators Software             }
{ http://www.astonshell.com/      }
{*********************************}

unit riscsd;


interface
USES sysutils, riscglob;


TYPE
diskstatetype = (
  diskCommand {!!!e unknown token},
  diskRead {!!!e unknown token},
  diskWrite {!!!e unknown token},
  diskWriting {!!!e unknown token});


bufty =  array [0..Pred(128)] of uint32_t;
buftyp2 =  array [0..Pred(128)+2] of uint32_t;

bytebufty = array[0..pred(512)] of uint8_t;

Diskty = OBJECT
      PRIVATE
        state : diskstatetype;
        myfile: THandle;
        rx_buf: bufty;
        rx_idx: longint;
        tx_buf: buftyp2;
        tx_cnt: longint;
        tx_idx: longint;
        offset : uint32_t;
      PUBLIC
        sdcard : Boolean;
        CONSTRUCTOR init(filename : string);
        procedure run_command;
      PRIVATE
        procedure read_sector(VAR buffer : bufty);
        procedure read_sector2(VAR buffer : buftyp2);
        procedure write_sector(buffer : bufty);
      PUBLIC
        function read_: uint32_t;
        procedure write_(value: uint32_t);
        DESTRUCTOR done;

end;


VAR disk : Diskty;



implementation


CONSTRUCTOR diskty.init(filename : string);

        VAR buffer : bufty;

        begin
        state := diskCommand;
        sdcard := False;
        buffer[0] := 0;
{$I-}
        writeln(' Filename : ', filename);
        myfile := fileOpen(filename, fmOpenReadWrite);
{$I+}
        if myfile = 0 then
                begin
                writeln('Can''t open file : ', filename,' ', ioresult);
                exit;
                end;

        (* Check for filesystem-only image, starting directly at sector 1 (DiskAdr 29) *)
        read_sector(buffer);
        IF (buffer[0] = $9B1EA38D) THEN offset := $80002 ELSE offset := 0;
        writeln(' File Offset : ', offset);
        sdcard := True;

        end;



DESTRUCTOR diskty.done;
begin
  fileclose(myfile);
end;

procedure diskty.write_(value: uint32_t);
begin
  inc(tx_idx);
  (* case statements in Pascal are breaking the case loop if
     the first condition is true *)
  case state of
    diskCommand:  begin
                  if ((byte(value)<>$FF) or (rx_idx<>0)) then
                     begin
                         rx_buf[rx_idx]:= value;
                         inc(rx_idx);
                         if rx_idx = 6 then
                            begin
                             run_command;
                             rx_idx:= 0;
                            end;
                     end;
                  end;
    diskRead:  begin
               if tx_idx = tx_cnt  then
                     begin
                      state:= diskCommand;
                      tx_cnt:= 0;
                      tx_idx:= 0;
                     end;
               end;
    diskWrite:  begin
                   if value = 254 then state:= diskWriting;
                end;
    diskWriting: begin
                  if rx_idx < 128 then rx_buf[rx_idx]:= value;
                  inc(rx_idx);
                  if rx_idx = 128 then write_sector(rx_buf);
                  if rx_idx = 130  then
                      begin
                        tx_buf[0] := 5;
                        tx_cnt := 1;
                        tx_idx:= -1;
                        rx_idx:= 0;
                        state:= diskCommand;
                      end;
                 end;
       end;{case}
   end;

function diskty.read_: uint32_t;
var resu: uint32_t;
begin
  if (tx_idx >= 0) and (tx_idx < tx_cnt)  then
        BEGIN
        resu:= tx_buf[tx_idx];
        END
      else
        BEGIN
        resu := 255;
(*        writeln('Error : tx_idx : ', tx_idx, ' tx_cnt : ', tx_cnt); *)
        END;
  read_ := resu;
end;

procedure diskty.run_command;
var cmd: uint32_t;
    arg: uint32_t;
    myreadpos, mywritepos : longint;

begin
  cmd := rx_buf[0];
  arg := (rx_buf[1] shl 24) or (rx_buf[2] shl 16) or (rx_buf[3] shl 8) or rx_buf[4];
  case cmd of
  81: begin
        state:= diskRead;
        tx_buf[0] := 0;
        tx_buf[1] := 254;
        myreadpos := fileseek(myfile, (arg - offset) * 512, fsFromBeginning);
(*        writeln('Readpos : ',myreadpos); *)
        read_sector2(tx_buf);
        tx_cnt:= 2+128;
      end;
  88: begin
        state:= diskWrite;
        mywritepos := fileseek(myfile, (arg - offset) * 512, fsFromBeginning);
        tx_buf[0]:= 0;
        tx_cnt:= 1;
(*        writeln('Writepos : ', mywritepos);  *)
      end;
    else
      begin
        tx_buf[0]:= 0;
        tx_cnt:= 1;
      end;
  end;{case?}
  tx_idx:= -1;
end;

procedure diskty.read_sector(VAR buffer : bufty);

var   bytes: bytebufty;
      i : 0..pred(128);
      i2 : 0..pred(512);


begin
  for i2 := 0 to pred(512) do

        begin
        bytes[i2] := 0;
        end;
  fileread(myfile, bytes, 512);
  for i := 0 to Pred(128)  do
   begin
    buffer[i]:= longword(bytes[i*4+0]) or (longword(bytes[i*4+1]) shl 8) or (longword(bytes[i*4+2]) shl 16) or (longword(bytes[i*4+3]) shl 24);
   end;
(*  writeln('Read sector1 buffer[0] : ', buffer[0]); *)

   end;


procedure diskty.read_sector2(VAR buffer : buftyp2);

var   bytes: bytebufty;
      i : 0..pred(128);
      i2 : 0..pred(512);


begin
  for i2 := 0 to pred(512) do

        begin
        bytes[i2] := 0;
        end;
  fileread(myfile, bytes, 512);
  for i := 0 to Pred(128)  do
   begin
    buffer[i+2]:= longword(bytes[i*4+0]) or (longword(bytes[i*4+1]) shl 8) or (longword(bytes[i*4+2]) shl 16) or (longword(bytes[i*4+3]) shl 24);
   end;
(*  writeln('Read sector2 buffer[2] : ', buffer[2]); *)

 end;




procedure diskty.write_sector(buffer : bufty);
 var  bytes: bytebufty;
      i : 0..pred(128);
 begin

  for i := 0 to Pred(128) do
     begin
       bytes[i*4+0]:= byte((buffer[i]) and $FF);
       bytes[i*4+1]:= byte((buffer[i] shr 8) and $FF);
       bytes[i*4+2]:= byte((buffer[i] shr 16) and $FF);
       bytes[i*4+3]:= byte((buffer[i] shr 24) and $FF);
     end;
  filewrite(myfile, bytes, 512);
end;

end.
